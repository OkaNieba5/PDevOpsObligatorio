# Documentacion



La documentación del código está la mayoría comentada dentro del mismo, pero a tener en cuenta:

En caso de no haber visto el PDF con las rutas absolutas, la ruta donde se ubican es:

	/home/nombre_del_usuario/Obligatorio2025/


## 1 -Script de Bash,

 1. Foto de la salida correcta del mismo

![Salida del script de bash](https://fi365-my.sharepoint.com/:i:/g/personal/fr306798_fi365_ort_edu_uy/Ed7MFzj6cz1KlLtc8VPsc1IBW-Ciuc_wjztlKqQnCD98Gg?e=kLctfX)


## Codigo del Script y explicando el funcionamiento.

	logFile="log_$(date +%Y%m%d_%H%M%S).rep"  #Nombre del archivo log.

	directorio_utilizado=""  #Inicializamos la variable del directorio vacia. dependiendo que se pase como parametro.

	log_archivo=false  # Condicion inciada en false para las opcion de guardar los caminos en el archivo log de getopts.

	solo_bash=false  # Condicion inciada en false para la condicion de busqueada solo de scripts de bash en getopts.

	  

	mkdir  -p  "$dir_backup"  #Nos aseguramos que el directorio de backup(directorio temporal) exista y este creado.

	  

	function  backup {

	local  directorio_used="$1"

	#Caso 1 Parametro -b, Buscamos solamente archivos ejecutables de Bash. El incio del archivo debe ser: '^#!/bin/bash'.

	if [ "$solo_bash"  =  true ];

	then

	#Abrimos un bloque de comandos para agrupar la salida a la tuberia.

	{

	#Explicacion de while con IFS= read -r -d $'\0', y find. utilizamos esto ya que al imprimir un caracter con el caracter nulo queremos que el delimitador sea el mismo.

	#Esto por que queremos el path absoluto de la carpeta, asi podemos evitar no perder alguna carpeta que contenga un espacio dentro su nombre.

	#IFS sera el un caracter vacio, evitando que se separen las letras en la entrada de find.

	#Buscamos solamente todos los directorios los cuales cumplan los requerimientos.

	#Que sean de tipo regular -type f asi podemos restringir la busqueda a solo estos archivos, luego adicionalmente filtramos que sea ejecutable para cualquiera de los usuarios.

	#Read estara delimitado con el caracter vacio, ya que, lo que es imprimimos al final del archivo encontrado para obtener la ruta absoluta del mismo. -print0.

	find  "$directorio_used"  -perm  -4000  -type  f  -executable  -print0  2>/dev/null  |

	while  IFS=  read  -r  -d  $'\0'  archivoEjecutable;

	do

	if  head  -n  1  "$archivoEjecutable"  2>/dev/null  |  egrep  -q  '^#!/bin/bash'; # Buscamos en al 1er linea unicamente para corroborar que es un script de Bash.

	then

	echo  -e  "${archivoEjecutable}\0"  # Mandamos el archivo ejecutable a la salida con el final nulo para el tar -T -.

	fi

	done

	#Si el log fue generado con la opcion -c, debera inclusie en el backup

	if [ "$log_archivo"  =  true ] && [ -f  "$dir_backup/$logfile" ];

	then

	echo  -e  "${dir_backup/logfile}\0"  # Mandamos el path del archivo .rep (log) con un caracter nulo al final para tar -T

	fi

	} |  tar  --null  -T  -  -czf  "$nombreFileBackup"  "$dir_backup"  2>/dev/null

	#En este caso el -T - va comprmir toda la salida completa dentro del bloque. Ya que viene de la stdin gracias al pipe.

	#Tar --null y - T, los cuales nos permiten delimitar la entrada por caracteres nulos pasadas a traves de find y ademas -T - indica que lea desde stdin(el resutlado de find) mediante un pipe.

	else  # Caso 2 Opcion sin -b, solamente script ejecutables en general, cumpliendo la condicion del SetUID.

	{ # Abrimos un bloque de comandos para redirigir la salida completa.

	find  "$directorio_used"  -perm  -4000  -type  f  -executable  -print0  2>/dev/null  # Repetimos el bloque find de la busqueda anterior.

	if  head  -n  1  "$archivoEjecutable"  2>/dev/null  |  egrep  -q  '^#!/bin/bash'; # Buscamos en al 1er linea unicamente para corroborar que es un script de Bash.

	then

	echo  -e  "${archivoEjecutable}\0"  # Mandamos el archivo ejecutable a la carpeta de backup(directorio de trabajo por defecto).

	fi

	#En este caso el tar va solamente recibir de la stdin el archivo ejecutable directamente para comprimir.

	} |  tar  --null  -T  -  -czf  "$dir_backup/$nombreFileBackup"  2>/dev/null  # Repetimos mismo procedimiento que en el caso 1.

	fi

	}

	  

	#Utilizaremos el comando getopts ya que nos permite procesar los modificadores que queremos crear para las 2 opciones de la letra.

	while  getopts  ":cb"  flags;

	do

	case  $flags  in

	c)

	#-c sera la opcion para procesar los caminos absolutos hacia el ejecutable encontrado. Por defecto la busqueda sera recursiva y para archivos regulares.

	log_archivo=true

	;;

	b)

	#-b sera la opcion para almacenar solamente los ejecutables que sean scripts de bash.

	solo_bash=true

	;;

	*)

	#Si la variable del modificador no es valida salimos con codigo 1

	echo  "El parametro "-$OPTARG" no es valido, por favor ingrese un parametro valido que sea -c o -s."  >&2

	exit  1

	;;

	esac

	done

	  

	#Si la cantidad de parametros coincide con el siguiente parametro que procesara getopts, entonces el directorio es el parametro $OPTIND.

	#Acomodamos la posicion del indice para que el mismo coincida con el directorio en $1. utilizando shift en $OPTIND - 1

	shift $((OPTIND-1))

	  
	  
	#Verificamos si el directorio existe, o si el parametro final es vacio.

	if [ -z  "$1" ]; then

	echo  "No se ingreso un directorio, se tomara el directorio "$HOME" por defecto."

	directorio_utilizado="$HOME"

	else

	if [ !  -d  $1 ];

	then

	echo  "El directorio "$1" no existe por favor indique uno que exista dentro del filesystem."  >&2

	exit  3

	fi

	directorio_utilizado="$1"

	fi

	  

	#Modificador -c activado, guardamos el archivo .rep del log en el directorio de backups.

	if [ "$log_archivo"  =  true ];

	then

	if [ "$solo_bash"  =  true ]; # Caso 1.1, tenemos -b activado para que busque solo el path del archivo bash.

	then

	find  "$directorio_utilizado"  -perm  -4000  -type  f  -executable  -print0  2>/dev/null  |

	while  IFS=  read  -r  -d  $'\0'  archivoEjecutable; do

	if  head  -n  1  "$archivoEjecutable"  2>/dev/null  |  egrep  -q  '^#!/bin/bash'; # Si la 1er linea del archivo ejecutable es #!/bin/bash entonces es un script de bash.

	then

	realpath  "$archivoEjecutable"  # Si el archivo es encontrado luego de pipear la anterior busqueda mandamos el archivo a un pipe hacia el directorio de backup.

	fi

	done  |  sort  >  "$dir_backup/$logFile"

	else

	"#Caso 1.2, no tenemos -b activado."

	find  "$directorio_utilizado"  -perm  -4000  -type  f  -executable  -print0  2>/dev/null  |  while  IFS=  read  -r  -d  $'\0'  archivoEjecutable; do  realpath  "$archivoEjecutable"

	done  |  sort  >  "$dir_backup/$logFile"

	fi

	fi

	  

	#Inciamos el backup.

	backup  "$directorio_utilizado"

	mv  "$nombreFileBackup"  "$HOME"  # Movemos el zip hacia el directorio $HOME.

	rm  -r  "$dir_backup"  # Eliminamos el directorio temporal.

	  

	#Si no se especifico ninguna opcion haremos solamente el backup del de los archivos ejecutables

	if [ "$log_archivo"  =  false ] && [ "$solo_bash"  =  false ];

	then

	echo  "No se ingreso ningun modificador (-c o -b), se procedera solamente a realizar el backup de los archivos."

	fi

## Como utilizar el Script

Nos movemos al directorio donde sera utilizado y luego corremos los siguientes comandos:

	 ./ej1_largo_caminos.sh	/path/al/directorio
Caso 1 -  Ningun modificador - Queremos realizar el archivo backup, sin los modificadores. Si no se ingresa ningun directorio, se tomará el directorio de trabajo por defecto.

	./ej1_largo_caminos.sh -c /path/al/directorio
Caso 2 - Modificador c - Queremos guardar los paths en un archivo log del directorio, ingresemos, además realiza el archio de backup.

	./ej1_largo_caminos.sh -cb /path/al/directorio
Caso 3 - Modificador - b - Buscará solamente scripts de bash, en el directorio que ingresemos, además realiza el archivo de backup solo con los mismos.

	./ej1_largo_caminos.sh -cb /path/al/directorio
Caso 3 - Modificador -c y - b - Queremos guardar los paths en un archivo log y buscará solamente scripts de bash, en el directorio que ingresemos, además realiza el archivo de backup.

## Formato del resultado del script

Deberá devolver en el directorio corriente un archivo con el siguiente formato:

Ejemplo:
`backup_SetUID-06-05-25_12-34-40.tar.gz`

El formato deberá ser --> backup_SetUID-fecha_hora.tar.gz

## Configuraciones adicionales

Para este caso no tendremos ninguna configuración adicional, más que utilizar el SO que venimos utilizando en clase - CentOS stream 9 en caso de ciertos problemas con comandos de una distribución a otra.


## 2- Script Python, creacion de Bucket S3.

Requerimientos antes de correr los scripts de python ---> 

Si no tenemos pip para utilizar con python debemos instalarlo:

	sudo dnf install python3-pip

Necesitamos bot3 para poder utilizar el framework correctamente con Python y interactuar con AWS

	pip-install boto3


## Como correr el Script 

Nos ubicamos en la carpeta raiz mencionada en el pdf de entrega y luego corremos el script de la siguiente manera:

	python bucketS3aws.py

## Código del Script y comentarios explicando el funcionamiento.
	
	import boto3

	from  datetime  import  datetime, timezone

	import  os  # Importamos el modulo os para saber el nombre exacto del file.

	import  glob  # Modulo para realizar busquedas con patrones como *.

	  

	# Agarramos la hora exacta

	fecha_actual  =  datetime.now()

	fecha_formateada  =  fecha_actual.strftime("%d-%m-%Y")

	  

	# Inciamos cliente s3 en AWS

	s3_client  =  boto3.client('s3')

	archivo_buscar  =  os.path.expanduser("~/backup_SetUID_*") # Path completo hacia el archivo del script bash.

	  

	# Buscamos el archivo real mediante como fue escrito.

	buscar_patron  =  glob.glob(archivo_buscar)

	archivo_name  =  buscar_patron[0] # el modulo glob crea una lista la cual podemos iterar para buscar el patron que se agrego a la misma, por defecto es 1 solo entonces el indice es 0.

	bucket_name  =  'el-maligno-306798'

	objecto_name  =  f"log_{fecha_formateada}"  # Extraemos el nombre del archivo desde el directorio indicado.

	  

	# Creamos el bucket S3 con el nombre deseado de la letra.

	boto3.client('s3').create_bucket(Bucket=bucket_name) # Asumimos que el bucket de S3 no esta creado aun.

	print(f"El bucket {bucket_name} fue creado con el nombre {objecto_name}")

	s3_client.upload_file(archivo_name, bucket_name, objecto_name) # Subimos los archivos al bucket de s3.

	print(f"El archivo {archivo_name} fue subido a {bucket_name}/{objecto_name}, para leerlo en su equipo por favor cambiele la extension a .tar.gz")


## 3- Script Python, creación de RDS.

Necesitaremos el conector de mysql para python:

	pip install mysql-connector-pyton

## Como correr el Script

	pyton RDSaws.py

 ## Código del Script y comentarios.

	import boto3
	import os
	import mysql.connector

	# Configuración de la base de datos RDS
	rds_client = boto3.client('rds')

	db_instance_identifier = 'Maligno-SRV'
	db_instance_class = 'db.t3.medium'  # Cambiado a una clase soportada
	engine = 'mysql'
	engine_version = '8.4.5'  # Especifica una versión soportada de MariaDB
	master_username = 'administrador'
	master_user_password = open("pwdrds.txt", 'r').read().strip()  # Asegúrate de que el archivo password.txt contenga la contraseña
	allocated_storage = int(os.environ.get('RDS_ALLOCATED_STORAGE', 20))
	publicly_accessible = True
	sql_filename = 'oblig.sql' # Nombre del archivo sql para los datos y crear todo lo necesario para la base de datos.

	try: # Realizaos un try, except ante cualquier error que surja al crear un RDS client.
	    response = rds_client.create_db_instance(
	        DBInstanceIdentifier=db_instance_identifier,
	        DBInstanceClass=db_instance_class,
	        Engine=engine,
	        EngineVersion=engine_version,
	        MasterUsername=master_username,
	        MasterUserPassword=master_user_password,
	        AllocatedStorage=allocated_storage
	    )
	    print(f"Creando instancia de base de datos RDS: {db_instance_identifier}")
	except Exception as e:
	    print(f"Error al crear la instancia de base de datos: {e}")

	# --- Obtener los detalles de la instancia para conectar ---
	try:
	    response = rds_client.describe_db_instances(DBInstanceIdentifier=db_instance_identifier)
	    db_instance = response['DBInstances'][0]
	    db_endpoint = db_instance['Endpoint']['Address']
	    db_port = db_instance['Endpoint']['Port']

	    print(f"Endpoint de la base de datos: {db_endpoint}:{db_port}")

	except Exception as e:
	    print(f"Error al obtener el endpoint de la base de datos: {e}")
	    exit(1)

	print(f"\nIntentando conectar a MySQL y ejecutar '{sql_file_name}'...")
	mysql_conn = None

	try:
	    # Intentar conexión
	    mysql_conn = mysql.connector.connect(
	        host=db_endpoint,
	        port=db_port,
	        user=master_username,
	        password=master_user_password,
	    )
	    cursor = mysql_conn.cursor()
	    # Conectar con MySQl y correr el archivo oblig.sql
	    mysql_conn = None
	    # Leer el archivo SQL
	    with open(sql_filename, 'r') as f:
	        sql_script = f.read()
	    for statement in sql_script.split(';'):
	            if statement.strip(): # Evita ejecutar sentencias vacías
	                try:
	                    cursor.execute(statement)
	                    print(f"Ejecutado: {statement.strip()[:70]}...") # Imprime solo los primeros 70 caracteres
	                except mysql.connector.Error as err:
	                    print(f"Error al ejecutar sentencia SQL: {err}")
	                    # Decide si quieres continuar a pesar de los errores o detenerte
	                    # raise # Descomenta para detener la ejecución en el primer error

	    mysql_conn.commit() # Confirmar los cambios si no estás en autocommit
	    print(f"El archivo '{sql_filename}' fue ejecutado exitosamente en la base de datos empleados.")

	except mysql.connector.Error as err:
	    print (f"Error de conexion a la base de datos MySQL: {err}")
